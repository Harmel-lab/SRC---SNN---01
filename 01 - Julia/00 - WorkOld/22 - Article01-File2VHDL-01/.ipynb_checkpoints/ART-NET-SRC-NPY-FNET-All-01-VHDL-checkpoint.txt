##########################################################
## Simulation d'un réseau de neurones - Li=100 et Lo=10 ##
##########################################################
##                 FPGA Model 1 - lecture NPY           ##
##                 --------------------------           ##
##                                       29-08-2025     ##
## programme test de l'ensemble des paramètres calculés ##
## par Florent.                                         ##
## Les données d'entrées -> MNIST recalculé en train de ##
## spikes avec longueur préfix null = 20                ##
##             longueur du train = 200                  ##
##             longueur suffix null = 0                 ##
##                                                      ##
## Ensemble des paramètres contenu dans un fichier JSON ##
## Ensemble des coéfficients des équations diff. -> NPZ ##
##                                                      ##
## NPY                                                  ##
## Lecture du vecteur de spike -> MNISTXX directory     ##
## choisi et lecture et analyse de ce vecteur par le    ##
## réseau de neurones -> en sortie le chiffre détecté.  ##
##                                                      ##
##                Pascal Harmeling 2025 - Uliège        ##
## Version 1 - Adapation du code 'NET-SRC-JSON-All-07'  ##
## Version 2 - Modification sur NeSrc3Fpga4             ##
##              -> appel fonction NeSrc3Fpga5           ##
## version 3 - ajustement des coefficients de la matrice##
##             forward_weightsp conforme à la matrice   ##
##             utilisée en VHDL                         ##
##########################################################

##########################################################
## PAS DE GRAPHIQUE NI INTERACT lib POUR LA RAPIDITE!   ##
##########################################################

# pour la lecture et le traitement du fichier JSON
using JSON3

# pour la lecture et le traitement du fichier NPZ
using NPZ

# pour la lecture et le traitement du fichier MNIST
using MLDatasets

# utilisation pour généréer les spikes des entrées des neurones - a=rand(Bernoulli(0.9), 100)
using Distributions

# utilisation si nécessaire pour affichage de résultats
using Plots
using Printf
#using Interact, WebIO
using LaTeXStrings

# utilisation de ma lib pour le modèle neuro - perso et Florent - pour mémoire 
# def using my lib -> neurone evec struct et fonction - entrées de spikes par vecteurs
include("../MyLib/FpgaLib-02.jl")

##########################################################
## Création méthodes de lecture fichier JSON3           ##
##########################################################
## programme pour la mise en place d'une lib            ##
## de lecture des différents paramètres codés dans un   ##
## fichier JSON3                                        ##
##                                                      ##
##                Pascal Harmeling 2023 - Uliège        ##
##                                                      ##
##########################################################

#################################################
## Function use JSON file input - read values  ##
#################################################
json_string = read("model/config.json", String)

FileJson = JSON3.read(json_string)

# principe d'accès aux éléments de la structure de données.
const cell_config_alphas=FileJson.cell_config.alphas
const cell_config_recurrence=FileJson.cell_config.recurrence
const cell_config_bias_max=FileJson.cell_config.bias_max
const cell_config_activation=FileJson.cell_config.activation
const cell_config_type=FileJson.cell_config.type
const cell_config_num_integrators_per_neuron=FileJson.cell_config.num_integrators_per_neuron

const dataset_config_encoding=FileJson.dataset_config.encoding
const dataset_config_seq_length::Int16=FileJson.dataset_config.seq_length
const dataset_config_prefix_length=FileJson.dataset_config.prefix_length
const dataset_config_suffix_length=FileJson.dataset_config.suffix_length
const dataset_config_rate_gain=FileJson.dataset_config.rate_gain
const dataset_config_name=FileJson.dataset_config.name
    
const input_size=FileJson.input_size
const hidden_size=FileJson.hidden_size
const hidden_layers=FileJson.hidden_layers
const output_size=FileJson.output_size
const readout_input_factor=FileJson.readout_input_factor

##########################################################
## Création méthodes de lecture fichier NPY             ##
##########################################################
## programme pour la mise en place d'une lib            ##
## de lecture des différents paramètres codés dans un   ##
## fichier NPY                                          ##
##                                                      ##
##                Pascal Harmeling 2023 - Uliège        ##
##                                                      ##
##########################################################

#################################################
## Function use NPY file input - read values   ##
#################################################

vars=npzread("model/arrays.npz")

#récupération des différents paramètres et valeurs initiales - si nécessaire vectorisation (vec())
const bias=get(vars,"l0_bias", 0)
const forward_weights=get(vars,"l0_forward_weights", 0)
const initial_h=get(vars,"l0_initial_h", 0)
const initial_hs=get(vars,"l0_initial_hs", 0)
const initial_i=vec(get(vars,"l0_initial_i", 0)[1,:,1])   #VECTORISATION 
const r=get(vars,"l0_r", 0)
const rho=get(vars,"l0_rho", 0)
const rs=get(vars,"l0_rs", 0)
const zs_dep=vec(get(vars,"l0_zs_dep", 0)[1,:])
#const zs_hyp=vec(get(vars,"l0_zs_hyp", 0)[1,:])
zs_hyp=vec(get(vars,"l0_zs_hyp", 0)[1,:])
fill!(zs_hyp, 0.81)
const readout=get(vars,"readout", 0)
const readoutp=round.(Int8, readout.*10)

#######################################################################
#lecture de la list MNist pour vérification du chiffre uniquement
#######################################################################
train_x, train_y = MNIST(split=:test)[:]

const Seq_length = dataset_config_seq_length
const Total_seq_length=dataset_config_prefix_length+dataset_config_seq_length+dataset_config_suffix_length
const DataFirst = dataset_config_prefix_length+1
const DataEnd = dataset_config_prefix_length+dataset_config_seq_length

#-----------------------------------------------------------------------------------------------------BEGIN-----
#---------------------------------------------------------------------------------------------------------------
#
# SETUP WORKBENCH 
# ---------------
#
# EDIT SETUP 
#
#---------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------
##paramètres obtenus lors des calculs du le projet
Fparam=Vector{Int16}(undef,5)
Fparam[1] = -3000
Fparam[2] = 940 # modification - permet d'adapter la fréquence des spikes - ATTENTION AVANT 0.99 -> Coeff. 1000 -- test avec 970
Fparam[3] = 100 # Zmin TOUJOURS à 100

fill!(zs_hyp, 0.940)

## quantization de la matrice de poids des SRC
MybinaryVal=16
Koeff= (abs(maximum(forward_weights)) > abs(minimum(forward_weights))) ? MybinaryVal/abs(maximum(forward_weights)) : MybinaryVal/abs(minimum(forward_weights))
const forward_weightsp=round.(Int16,(get(vars,"l0_forward_weights", 0).*Koeff))

global filenameT = "OutputSpikingCompare(Zmax" * lpad(string(Fparam[2]), 3, '0') * "-" *  lpad(string(zs_hyp[1]), 3, '0') * "_" * lpad(string(Total_seq_length), 3, '0') * "_S01_intZERO_" * lpad(string(MybinaryVal), 3, '0') * ").txt"

#-------------------------------------------------------------------------------------------------------END-----
#---------------------------------------------------------------------------------------------------------------
#######################################################################
# à définir pour le début et le nombre d'image crée pour le fichier COE
#######################################################################
#                              Attention
#
# - la taille de la zone => MaxImg
#      il se peut que la BRAM soit trop petite pour contenir le fichier -> reduire MaxImg
# - StartImg+MaxImg<=10000 
# - StSize => toujours '1', '2', '4', '5' ou 10
#             - '1' -> 20 black + 200 spicking trace - '220'
#             - '2' -> 10 black + 100 spicking trace - '110'
#             - '4' ->  5 black +  50 spicking trace - '055'
#             - '5' ->  4 black +  40 spicking trace - '044'
#             - '10'->  2 black +  20 spicking trace - '022'
#
#######################################################################

const StSize = 5
const PosSt::Int8 = 1
const StartImg::Int16 = 0001 
const StopImg::Int16 = 10000


#################################################
## analyse des valeurs des constantes          ##
#################################################    
## calcul des valeurs limites
NbrBlack::Int32 = 20 / StSize
NbrSpiking::Int32 = 200 / StSize

## férification des conditions limites
if (StopImg> (last(size(train_x))))
    error("ERROR -> La valeur de StopImg est supérieure à la taille max de train_x, arrêt du programme.")
end
 
if ((StSize != 1) && (StSize != 2) && (StSize != 4) && (StSize != 5) && (StSize != 10))
    error("ERROR -> La valeur de StSize doit valoir '1','2','4' ou '5', arrêt du programme.")
end

if (PosSt>StSize) 
    error("ERROR -> La valeur de PosSpike doit valoir '1','2','4','5' ou '10' et inf ou égal à StSize, arrêt du programme.")
end

#################################################
## Function lecture du fichier npy             ##
#################################################
##constante - Lire un fichier .npy
const a = "./MNIST/" ## -> à adapter suivant besoin
const b = "Npy/"
const name = "spiking_number00001.npy" ## supprimer le numéro en fin de programmation !!!!!!!!!!!!!!!!!

# Définir les chemin de travail
dir_pathread = a * b

#################################################
## analyse des chemins et noms de fichiers     ##
#################################################    
if !(isdir(dir_pathread))
    error("ERROR -> Le répertoire de lecture des fichiers n'existe pas -> fin de programme.")
end

#################################################
## création et initialisation des variables de ##
## travail                                     ##
#################################################
XORTSspikes = zeros(Bool, 28,28,NbrBlack+NbrSpiking)
array = zeros(Bool, 28,28,220)

# Mise en place des vecteurs
STs = size(train_x)
global TSspikes = zeros(Bool, STs[1],STs[2],Total_seq_length)

#initialisation des variables is, us
is=zeros(Float32,Total_seq_length,100)
us=zeros(Float32,Total_seq_length,100)

#initialisation des variables h, z, hs, Sout et Rout - méthode de Florent
h=zeros(Float32,Total_seq_length,100)
z=zeros(Float32,Total_seq_length,100)
hs=zeros(Float32,Total_seq_length,100)
Sout=zeros(Float32,Total_seq_length,100)

RoutFB=zeros(Float32,Total_seq_length,10) # avec feedback 0.99 -> avec Leackage
RoutW =zeros(Float32,Total_seq_length,10) # sans feedback      -> intégrateur pure


#initialisation des variables hp, zp, hsp, Soutp et Rout - méthode de Pascal
isp=zeros(Int32,Total_seq_length,100)
Sum=zeros(Int32,Total_seq_length,100)
ispstat=zeros(Int32,Total_seq_length,100)

isps::Int16=0

hp=zeros(Int16,Total_seq_length,100)
zp=zeros(Int16,Total_seq_length,100)
hsp=zeros(Int16,Total_seq_length,100)

Soutp=zeros(Int8,Total_seq_length,100)

RoutpFB=zeros(Int32,Total_seq_length,10) # avec feedback 0.99 -> avec Leackage
RoutpW=zeros(Int32,Total_seq_length,10)  # sans feedback      -> intégrateur pure
MaxRoutpW=0

#initialisation des spikes time
TSspikes = zeros(Bool, STs[1],STs[2],Total_seq_length)
TauxErrorFFB::Int16 = 0
TauxErrorPFB::Int16 = 0
TauxErrorFW::Int16 = 0
TauxErrorPW::Int16 = 0

#gestiondu temps durée de la boucle
t1=time()

filenameO = "OutputSpikingCompare(Zmax" * lpad(string(Fparam[2]), 3, '0') * "-" *  lpad(string(zs_hyp[1]), 3, '0') * "_SP" * lpad(string(NbrBlack+NbrSpiking), 3, '0') * "_B" * lpad(string(MybinaryVal), 3, '0') * ").txt"
file = open(filenameO, "a") #open file with add 
@printf(file, "Flo : zs_dep %f - zs_hyp %f \n", zs_dep[1],zs_hyp[1] )
@printf(file, "VHDL: zs_dep %f - zs_hyp %f \n\n", Fparam[3],Fparam[2] )
@printf(file, "Struct NbrBlack :  %3i - NbrSpiking : %3i - StartImg : %5i - StopImg : %5i - PosSt %1i \n\n",NbrBlack ,NbrSpiking,StartImg ,StopImg ,PosSt)

##########################################################
## activité neuronal - Boucle principale                ##
########################################################## 
Img::Int16 = 0
global Img
## boucle principale pour le parcour des MaxImg en commencant en  StartImg
for  Img in StartImg:StopImg

    ##########################################################
    ## activité neuronal - génération du train de Spikes    ##
    ##########################################################     
    Num = string(bitstring(train_y[Img]))[61:64]
    filename = dir_pathread  *"spiking_number" * lpad(string(Img), 5, '0') * ".npy"
    #println(filename)
    if !(isfile(filename))
        println("ERROR -> $filename")
        error("ERROR -> le fichier *.npy n'existe pas")
    end
    
    array = npzread(filename)
    XORTSspikes = zeros(Bool, 28,28,NbrBlack+NbrSpiking)
    XORTSspikes[:,:,(NbrBlack+1)] = array[:,:,(21 + ((PosSt - 1) * NbrSpiking))]
    XORTSspikes[:,:,(NbrBlack+NbrSpiking)] = >=(0.5).(train_x[:,:,Img]) ## set last display to check answer

    ##génération spiking trace without two spikes ...
    for i in 2:(NbrSpiking-1)
        XORTSspikes[:,:,(NbrBlack+i)] = (XORTSspikes[:,:,(NbrBlack+i-1)] .⊻  array[:,:,(20+ ((PosSt - 1) * NbrSpiking)+i)] ) .& array[:,:,(20+ ((PosSt - 1) * NbrSpiking)+i)]
    end
    
    ##########################################################
    ## activité neuronal - analyse du train de Spikes       ##
    ##########################################################
    # Réalisation de la simulation du réseaux de neurones SSN -> SRC
    # 2 méthodes sont utilisée - méthode de Florent et méthode de Pascal.
    for i in 1:(NbrBlack+NbrSpiking)
        
        #picture (2D) to vector
        VTSspikes=vec(XORTSspikes[:,:,i])
        
        #calcul des 100 SRC
        for j in 1:100
            
            #calcul du courant 'is' et de la tension 'us' suivant (forward_weights,VTSspikes,cell_config_alphas,rho)
            if i==1 #condition initiale de i
                global is[1,j]=sum(forward_weights[j,:].*VTSspikes)+initial_i[j]
                global isp[1,j]=sum(forward_weightsp[j,:].*VTSspikes)
                global Sum[1,j]= isp[1,j]
            else
                # global is[i,j]=is[i-1,j]*cell_config_alphas[1] + sum(forward_weights[j,:].*VTSspikes) - test shift divisor 16 et 32
                global is[i,j]=(is[i-1,j] - (is[i-1,j]/16 + is[i-1,j]/32)) + sum(forward_weights[j,:].*VTSspikes)
                global  Sum[i,j]= (sum(forward_weightsp[j,:].*VTSspikes))
                global isp[i,j]=(isp[i-1,j] - (isp[i-1,j]>>4 + isp[i-1,j]>>5)) + Sum[i,j]
            end
            global us[i,j]=rho[j]*tanh((1/rho[j])*is[i,j])        
                        
            #Calcul suivant la méthode de  ------------- FLORENT -------------
            #calcul de h, z, hs et Sout
            if i==1   #conditions initiales h,z et hs
                global h[1,j]=initial_h[j]
                global z[1,j]=zs_hyp[j]- (zs_hyp[j] - zs_dep[j]) * (1 / (1+exp(-10 * -0.5)))
                global hs[1,j]=initial_hs[j]
            else
                global h[i,j]=tanh(us[i,j] + r[j]*h[i-1,j] + rs[j]*hs[i-1,j] + bias[j])
                global z[i,j]=zs_hyp[j]- (zs_hyp[j] - zs_dep[j]) * (1 / (1+exp(-10 * (h[i-1,j]-0.5))))
                global hs[i,j]=z[i,j]*hs[i-1,j]+(1-z[i,j])*h[i-1,j]
            end
            Sout[i,j]=ifelse(h[i,j]>0.5,1,0) 
            
            #Calcul suivant la méthode de  ------------- PASCAL ------------- lib 
            #calcul de hp, zp, hsp et Soutp
            if i==1   #conditions initiales h,z et hs
                global hp[1,j]=0 #-1024
                global hsp[1,j]=0 #-800
                global zp[1,j]=0
            else
                if isp[i,j]>0         # !!!! Peut être modifier la valeur de référence (0.91 dans la version précédente)
                    # courant d'entrée ok -> excitation .. + 1000
                    isps = 1023
                else
                    # pas de courant d'entrée .. -1000
                    isps = -1024
                end
                ispstat[i,j]=isps
                global hp[i,j],hsp[i,j],zp[i,j]=NeSRC3Fpga5!(isps, hp[i-1,j], hsp[i-1,j],Fparam)
            end
           
            Soutp[i,j]=ifelse(hp[i,j]>=512,1,0) 
            
        end

        #calcul les 10 Rout
        for j in 1:10
           #Calcul suivant la méthode de  ------------- FLORENT -------------
           if i==1
                #calcul le vecteur d'entrée (100 éléments)
                global RoutFB[i,j]=sum(readout[j,:].* Sout[i,:])
                global RoutW[i,j]=sum(readout[j,:].* Sout[i,:])
            else
                global RoutFB[i,j]=0.96875*RoutFB[i-1,j]+sum(readout[j,:].* Sout[i,:]) # 1-( 1/32)
                global RoutW[i,j]=RoutW[i-1,j]+sum(readout[j,:].* Sout[i,:])
            end

            #Calcul suivant la méthode de  ------------- PASCAL -------------
           if i==1
                #calcul le vecteur d'entrée (100 éléments)
                global RoutpFB[i,j]=sum(readoutp[j,:].* Soutp[i,:])
                global RoutpW[i,j]=sum(readoutp[j,:].* Soutp[i,:])
            else
                global RoutpFB[i,j]=(((RoutpFB[i-1,j]<<5)-RoutpFB[i-1,j])>>5)+(sum(readoutp[j,:].* Soutp[i,:])) # 1-( 1/32)
                global RoutpW[i,j]=RoutpW[i-1,j]+(sum(readoutp[j,:].* Soutp[i,:])) 

                if (MaxRoutpW<RoutpW[i,j]) MaxRoutpW=RoutpW[i,j] end
            end
        end

        #debug #########################
        #index=43
        #pos=i
        #@printf("%4i : %5i :   %5i :%5i : %5i :   %5i :  %5i :  %5i :  %5i : %5i : %5i : %5i : %5i : %5i : %5i : %5i : %5i : \n ",pos,Sum[pos,index],isp[pos,index], ispstat[pos,index], hp[pos,index],hsp[pos,index], Soutp[pos,index], RoutpW[pos,1],RoutpW[pos,2],RoutpW[pos,3],RoutpW[pos,4],RoutpW[pos,5],RoutpW[pos,6],RoutpW[pos,7],RoutpW[pos,8],RoutpW[pos,9],RoutpW[pos,10])
   
    end 

    # Réalisation de l'analyse des Rout pour définir le chiffre trouvé
    #Calcul suivant la méthode de  ------------- FLORENT -------------
    solFB::Int8 = last(findmax(RoutFB[NbrBlack+NbrSpiking,:]))-1
    solW::Int8 = last(findmax(RoutW[NbrBlack+NbrSpiking,:]))-1
    #Calcul suivant la méthode de  ------------- PASCAL -------------
    solpFB::Int8 = last(findmax(RoutpFB[NbrBlack+NbrSpiking,:]))-1
    solpW::Int8 = last(findmax(RoutpW[NbrBlack+NbrSpiking,:]))-1
    
    
    if (solFB==train_y[Img]) && (solW==train_y[Img]) && (solpFB==train_y[Img]) && (solpW==train_y[Img])
    else
        if (solFB!=train_y[Img]) global TauxErrorFFB+=1 end
        if (solW!=train_y[Img]) global TauxErrorFW+=1 end
        if (solpFB!=train_y[Img]) global TauxErrorPFB+=1 end
        if (solpW!=train_y[Img]) global TauxErrorPW+=1 end
    end
    @printf("position %5d : réel=%1d : T-Flo-FB=%1d : T-Flo-W=%1d : T-VHDL-FB=%1d : T-VHDL-W=%1d : E-FLO-FB=%3d : E-FLO-W=%3d : E-VHDL-FB=%3d : E-VHDL-W=%3d \n",Img, train_y[Img], solFB, solW, solpFB, solpW, TauxErrorFFB, TauxErrorFW, TauxErrorPFB,  TauxErrorPW )
    @printf(file, "position %5d : réel=%1d : T-Flo-FB=%1d : T-Flo-W=%1d : T-VHDL-FB=%1d : T-VHDL-W=%1d : E-FLO-FB=%3d : E-FLO-W=%3d : E-VHDL-FB=%3d : E-VHDL-W=%3d \n",Img, train_y[Img], solFB, solW, solpFB, solpW, TauxErrorFFB, TauxErrorFW, TauxErrorPFB,  TauxErrorPW )
end
#gestiondu temps durée de la boucle
t2=time()
@printf("durée des calculs (secondes) : %f",(t2-t1))
close(file)




##########################################################
## Simulation d'un réseau de neurones - Li=100 et Lo=10 ##
##########################################################
##                 FPGA Model 1 - lecture NPY           ##
##                 --------------------------           ##
##                                       29-08-2025     ##
## programme test de l'ensemble des paramètres calculés ##
## par Florent.                                         ##
## Les données d'entrées -> MNIST recalculé en train de ##
## spikes avec longueur préfix null = 20                ##
##             longueur du train = 200                  ##
##             longueur suffix null = 0                 ##
##                                                      ##
## Ensemble des paramètres contenu dans un fichier JSON ##
## Ensemble des coéfficients des équations diff. -> NPZ ##
##                                                      ##
## NPY                                                  ##
## Lecture du vecteur de spike -> MNISTXX directory     ##
## choisi et lecture et analyse de ce vecteur par le    ##
## réseau de neurones -> en sortie le chiffre détecté.  ##
##                                                      ##
##                Pascal Harmeling 2025 - Uliège        ##
## Version 1 - Adapation du code 'NET-SRC-JSON-All-07'  ##
## Version 2 - Modification sur NeSrc3Fpga4             ##
##              -> appel fonction NeSrc3Fpga5           ##
## version 3 - ajustement des coefficients de la matrice##
##             forward_weightsp conforme à la matrice   ##
##             utilisée en VHDL                         ##
##########################################################

##########################################################
## PAS DE GRAPHIQUE NI INTERACT lib POUR LA RAPIDITE!   ##
##########################################################

# pour la lecture et le traitement du fichier JSON
using JSON3

# pour la lecture et le traitement du fichier NPZ
using NPZ

# pour la lecture et le traitement du fichier MNIST
using MLDatasets

# utilisation pour généréer les spikes des entrées des neurones - a=rand(Bernoulli(0.9), 100)
using Distributions

# utilisation si nécessaire pour affichage de résultats
using Plots
using Printf
#using Interact, WebIO
using LaTeXStrings

# utilisation de ma lib pour le modèle neuro - perso et Florent - pour mémoire 
# def using my lib -> neurone evec struct et fonction - entrées de spikes par vecteurs
include("../MyLib/FpgaLib-01.jl")

##########################################################
## Création méthodes de lecture fichier JSON3           ##
##########################################################
## programme pour la mise en place d'une lib            ##
## de lecture des différents paramètres codés dans un   ##
## fichier JSON3                                        ##
##                                                      ##
##                Pascal Harmeling 2023 - Uliège        ##
##                                                      ##
##########################################################

#################################################
## Function use JSON file input - read values  ##
#################################################
json_string = read("model/config.json", String)

FileJson = JSON3.read(json_string)

# principe d'accès aux éléments de la structure de données.
const cell_config_alphas=FileJson.cell_config.alphas
const cell_config_recurrence=FileJson.cell_config.recurrence
const cell_config_bias_max=FileJson.cell_config.bias_max
const cell_config_activation=FileJson.cell_config.activation
const cell_config_type=FileJson.cell_config.type
const cell_config_num_integrators_per_neuron=FileJson.cell_config.num_integrators_per_neuron

const dataset_config_encoding=FileJson.dataset_config.encoding
const dataset_config_seq_length::Int16=FileJson.dataset_config.seq_length
const dataset_config_prefix_length=FileJson.dataset_config.prefix_length
const dataset_config_suffix_length=FileJson.dataset_config.suffix_length
const dataset_config_rate_gain=FileJson.dataset_config.rate_gain
const dataset_config_name=FileJson.dataset_config.name
    
const input_size=FileJson.input_size
const hidden_size=FileJson.hidden_size
const hidden_layers=FileJson.hidden_layers
const output_size=FileJson.output_size
const readout_input_factor=FileJson.readout_input_factor

##########################################################
## Création méthodes de lecture fichier NPY             ##
##########################################################
## programme pour la mise en place d'une lib            ##
## de lecture des différents paramètres codés dans un   ##
## fichier NPY                                          ##
##                                                      ##
##                Pascal Harmeling 2023 - Uliège        ##
##                                                      ##
##########################################################

#################################################
## Function use NPY file input - read values   ##
#################################################

vars=npzread("model/arrays.npz")

#récupération des différents paramètres et valeurs initiales - si nécessaire vectorisation (vec())
const bias=get(vars,"l0_bias", 0)
const forward_weights=get(vars,"l0_forward_weights", 0)

## quantization de la matrice de poids des SRC
MybinaryVal = 256
Koeff= (abs(maximum(forward_weights)) > abs(minimum(forward_weights))) ? MybinaryVal/abs(maximum(forward_weights)) : MybinaryVal/abs(minimum(forward_weights))
const forward_weightsp=round.(Int16,(get(vars,"l0_forward_weights", 0).*Koeff))

const initial_h=get(vars,"l0_initial_h", 0)
const initial_hs=get(vars,"l0_initial_hs", 0)
const initial_i=vec(get(vars,"l0_initial_i", 0)[1,:,1])   #VECTORISATION 
const r=get(vars,"l0_r", 0)
const rho=get(vars,"l0_rho", 0)
const rs=get(vars,"l0_rs", 0)
const zs_dep=vec(get(vars,"l0_zs_dep", 0)[1,:])
const zs_hyp=vec(get(vars,"l0_zs_hyp", 0)[1,:])
const readout=get(vars,"readout", 0)
const readoutp=round.(Int8, readout.*10)

@printf("zs_dep %f - zs_hyp %f \n", zs_dep[1],zs_hyp[1] )

##########################################################
## Lecture MNIST et génération Spiking train            ##
##########################################################
## programme pour la mise en place d'une lib            ##
## réalisant la lecture du fichier MNIST.               ##
## conversion en train de spikes d'un des éléments de   ##
## MNIST sur base d'un Interactive slide.               ##
## -> utilisation de la fonction proba Bernoulli avec   ##
##    un gain (0<=gain<=1).                             ##
##                                                      ##
##                Pascal Harmeling 2023 - Uliège        ##
##                                                      ##
##########################################################
##constante - répertoires
const a = "./MNIST01/" ## -> à adapter suivant besoin
const b = "NPY/"

# Définir les chemin de travail
dir_pathread = a * b

#lecture de la list MNist pour vérification du chiffre uniquement
train_x, train_y = MNIST(split=:test)[:]

# nombre d'éléments dans les tableaux et parcour boucles- constantes divers
const Seq_length = dataset_config_seq_length
const Total_seq_length=dataset_config_prefix_length+dataset_config_seq_length+dataset_config_suffix_length
const DataFirst = dataset_config_prefix_length+1
const DataEnd = dataset_config_prefix_length+dataset_config_seq_length

# Mise en place des vecteurs
STs = size(train_x)
global TSspikes = zeros(Bool, STs[1],STs[2],Total_seq_length)

#initialisation des variables is, us
is=zeros(Float32,Total_seq_length,100)
us=zeros(Float32,Total_seq_length,100)

#initialisation des variables h, z, hs, Sout et Rout - méthode de Florent
h=zeros(Float32,Total_seq_length,100)
z=zeros(Float32,Total_seq_length,100)
hs=zeros(Float32,Total_seq_length,100)
Sout=zeros(Float32,Total_seq_length,100)

RoutFB=zeros(Float32,Total_seq_length,10) # avec feedback 0.99 -> avec Leackage
RoutW =zeros(Float32,Total_seq_length,10) # sans feedback      -> intégrateur pure


#initialisation des variables hp, zp, hsp, Soutp et Rout - méthode de Pascal
isp=zeros(Int32,Total_seq_length,100)

isps::Int16=-1024

hp=zeros(Int16,Total_seq_length,100)
zp=zeros(Int16,Total_seq_length,100)
hsp=zeros(Int16,Total_seq_length,100)

Soutp=zeros(Int8,Total_seq_length,100)

RoutpFB=zeros(Int32,Total_seq_length,10) # avec feedback 0.99 -> avec Leackage
RoutpW=zeros(Int32,Total_seq_length,10)  # sans feedback      -> intégrateur pure

#paramètres obtenus lors des calculs du le projet
Fparam=Vector{Int16}(undef,5)
Fparam[1] = -3000
Fparam[2] = 910 # modification - permet d'adapter la fréquence des spikes - ATTENTION AVANT 0.99 -> Coeff. 1000 -- test avec 970
Fparam[3] = 000 # Zmin TOUJOURS à 100

#initialisation des spikes time
TSspikes = zeros(Bool, STs[1],STs[2],Total_seq_length)
Gain=0.25
Spi=100
TauxErrorFFB::Int16 = 0
TauxErrorPFB::Int16 = 0
TauxErrorFW::Int16 = 0
TauxErrorPW::Int16 = 0

#gestiondu temps durée de la boucle
t1=time()

filename = "OutputSpikingCompare(Zmax" * lpad(string(Fparam[2]), 3, '0') * "Binary" * lpad(string(MybinaryVal), 3, '0') * ".txt"
file = open(filename, "a") #open file with add 
@printf(file, "Flo : zs_dep %f - zs_hyp %f \n", zs_dep[1],zs_hyp[1] )
@printf(file, "VHDL: zs_dep %f - zs_hyp %f \n\n", Fparam[3],Fparam[2] )

for Img=1:1:STs[3]
 
    # SPIKES TIMES - Mise en place des vecteurs d'impulsion spikes - 
    # SPIKES TIMES - on va utiliser les mêmes spikes times pour les deux méthodes de résolution
    if isdir(dir_pathread)
        # le répertoire source existe
        filename = dir_pathread  *"spiking_number" * lpad(string(Img), 5, '0') * ".npy"
        if isfile(filename)
            TSspikes = npzread(filename)
        else
            println("Le nom de fichier n'existe pas -> fin de programme.")
        end
    else
        println("Le répertoire n'existe pas -> fin de programme.")
    end
    
    ##########################################################
    ## activité neuronal - analyse du train de Spikes       ##
    ##########################################################
    ## programme qui réalise la simulation d'un réseau de   ##
    ## neurones. Le réseau analyse un train de spikes afin  ##
    ## de retourner en sorite la valeur                     ##
    ## MNIST sur base d'un Interactive slide.               ##
    ## -> utilisation de la fonction proba Bernoulli avec   ##
    ##    un gain (0<=gain<=1).                             ##
    ##                                                      ##
    ##                Pascal Harmeling 2023 - Uliège        ##
    ##                                                      ##
    ##########################################################
    
    # Réalisation de la simulation du réseaux de neurones SSN -> SRC
    # 2 méthodes sont utilisée - méthode de Florent et méthode de Pascal.
    for i in 1:(Total_seq_length)
        
        #picture (2D) to vector
        VTSspikes=vec(TSspikes[:,:,i])
        
        #calcul des 100 SRC
        for j in 1:100
            
            #calcul du courant 'is' et de la tension 'us' suivant (forward_weights,VTSspikes,cell_config_alphas,rho)
            if i==1 #condition initiale de i
                global is[1,j]=sum(forward_weights[j,:].*VTSspikes)+initial_i[j]
                global isp[1,j]=sum(forward_weightsp[j,:].*VTSspikes)
            else
                # global is[i,j]=is[i-1,j]*cell_config_alphas[1] + sum(forward_weights[j,:].*VTSspikes) - test shift divisor 16 et 32
                global is[i,j]=(is[i-1,j] - (is[i-1,j]/16 + is[i-1,j]/32)) + sum(forward_weights[j,:].*VTSspikes)
                global isp[i,j]=((isp[i-1,j] - (isp[i-1,j]>>4 + isp[i-1,j]>>5)) + (sum(forward_weightsp[j,:].*VTSspikes)))
            end
            global us[i,j]=rho[j]*tanh((1/rho[j])*is[i,j])        
                        
            #Calcul suivant la méthode de  ------------- FLORENT -------------
            #calcul de h, z, hs et Sout
            if i==1   #conditions initiales h,z et hs
                global h[1,j]=initial_h[j]
                global z[1,j]=zs_hyp[j]- (zs_hyp[j] - zs_dep[j]) * (1 / (1+exp(-10 * -0.5)))
                global hs[1,j]=initial_hs[j]
            else
                global h[i,j]=tanh(us[i,j] + r[j]*h[i-1,j] + rs[j]*hs[i-1,j] + bias[j])
                global z[i,j]=zs_hyp[j]- (zs_hyp[j] - zs_dep[j]) * (1 / (1+exp(-10 * (h[i-1,j]-0.5))))
                global hs[i,j]=z[i,j]*hs[i-1,j]+(1-z[i,j])*h[i-1,j]
            end
            Sout[i,j]=ifelse(h[i,j]>0,h[i,j],0) 
            
            #Calcul suivant la méthode de  ------------- PASCAL ------------- lib 
            #calcul de hp, zp, hsp et Soutp
            if i==1   #conditions initiales h,z et hs
                global hp[1,j]=0
                global hsp[1,j]=0
                global zp[1,j]=Fparam[3]
            else
                if isp[i,j]>0         # !!!! Peut être modifier la valeur de référence (0.91 dans la version précédente)
                    # courant d'entrée ok -> excitation .. + 1000
                    isps = 1023
                else
                    # pas de courant d'entrée .. -1000
                    isps = -1024
                end
                global hp[i,j],hsp[i,j],zp[i,j]=NeSRC3Fpga5!(isps, hp[i-1,j], hsp[i-1,j], Fparam)
            end
            # cette comparaison permet de faire une interface simple de sortie -> rien à faire
            # la valeur de seuil (ici 400 par défaut) peut être ajustée pour optimiser le résultat
            
            # if (j==32) @printf("courant : %1.2f -> hf : %1.2f - courant : %1.2f -> hp : %d \n", us[i,j], h[i,j],isps, hp[i,j]) end
            Soutp[i,j]=ifelse(hp[i,j]>=512,1,0) 
            
        end

        #calcul les 10 Rout
        for j in 1:10
           #Calcul suivant la méthode de  ------------- FLORENT -------------
           if i==1
                #calcul le vecteur d'entrée (100 éléments)
                global RoutFB[i,j]=sum(readout[j,:].* Sout[i,:])
                global RoutW[i,j]=sum(readout[j,:].* Sout[i,:])
            else
                global RoutFB[i,j]=0.992*RoutFB[i-1,j]+sum(readout[j,:].* Sout[i,:]) # 1-( 1/128)
                global RoutW[i,j]=RoutFB[i-1,j]+sum(readout[j,:].* Sout[i,:])
            end

            #Calcul suivant la méthode de  ------------- PASCAL -------------
           if i==1
                #calcul le vecteur d'entrée (100 éléments)
                global RoutpFB[i,j]=sum(readoutp[j,:].* Soutp[i,:])
                global RoutpW[i,j]=sum(readoutp[j,:].* Soutp[i,:])
            else
                # global Routp[i,j]=0.984*Routp[i-1,j]+sum(readoutp[j,:].* Soutp[i,:])
                # la division par 128 permet dans la FPGA de réaliser '>>7'
                # le remplacement par un test if de la solution de produit '.*' par une somme simplifiée ----------- todo -----------------
                # dans le code VHDL on remplacera le produit par une somme dans une boucle avec : 
                #    - si *1 -> add Soutp
                #    - si *10 -> add (Soutp<<3 + Soutp<<1) 
                #
                global RoutpFB[i,j]=(RoutpFB[i-1,j]-(RoutpFB[i-1,j]>>7))+(sum(readoutp[j,:].* Soutp[i,:])) # 1-( 1/128)
                global RoutpW[i,j]=RoutpW[i-1,j]+(sum(readoutp[j,:].* Soutp[i,:])) 
            end
            
            
        end
    end 

    # Réalisation de l'analyse des Rout pour définir le chiffre trouvé
    #Calcul suivant la méthode de  ------------- FLORENT -------------
    solFB::Int8 = last(findmax(RoutFB[Total_seq_length,:]))-1
    solW::Int8 = last(findmax(RoutW[Total_seq_length,:]))-1
    #Calcul suivant la méthode de  ------------- PASCAL -------------
    solpFB::Int8 = last(findmax(RoutpFB[Total_seq_length,:]))-1
    solpW::Int8 = last(findmax(RoutpW[Total_seq_length,:]))-1
    
    
    if (solFB==train_y[Img]) && (solW==train_y[Img]) && (solpFB==train_y[Img]) && (solpW==train_y[Img])
    else
        if (solFB!=train_y[Img]) global TauxErrorFFB+=1 end
        if (solW!=train_y[Img]) global TauxErrorFW+=1 end
        if (solpFB!=train_y[Img]) global TauxErrorPFB+=1 end
        if (solpW!=train_y[Img]) global TauxErrorPW+=1 end
    end
    @printf("position %5d : réel=%1d : T-Flo-FB=%1d : T-Flo-W=%1d : T-VHDL-FB=%1d : T-VHDL-W=%1d : E-FLO-FB=%3d : E-FLO-W=%3d : E-VHDL-FB=%3d : E-VHDL-W=%3d \n",Img, train_y[Img], solFB, solW, solpFB, solpW, TauxErrorFFB, TauxErrorFW, TauxErrorPFB,  TauxErrorPW )
    @printf(file, "position %5d : réel=%1d : T-Flo-FB=%1d : T-Flo-W=%1d : T-VHDL-FB=%1d : T-VHDL-W=%1d : E-FLO-FB=%3d : E-FLO-W=%3d : E-VHDL-FB=%3d : E-VHDL-W=%3d \n",Img, train_y[Img], solFB, solW, solpFB, solpW, TauxErrorFFB, TauxErrorFW, TauxErrorPFB,  TauxErrorPW )
#if (TauxErrorP>0) break
end
#gestiondu temps durée de la boucle
t2=time()
@printf("durée des calculs (secondes) : %f",(t2-t1))
close(file)
